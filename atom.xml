<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Three-pigs的平淡笔记</title>
  
  <subtitle>你好你好</subtitle>
  <link href="http://three-pigs.github.io/atom.xml" rel="self"/>
  
  <link href="http://three-pigs.github.io/"/>
  <updated>2020-11-15T15:11:34.962Z</updated>
  <id>http://three-pigs.github.io/</id>
  
  <author>
    <name>Three_Pigs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python笔记</title>
    <link href="http://three-pigs.github.io/2020/11/15/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://three-pigs.github.io/2020/11/15/python%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-15T15:11:09.000Z</published>
    <updated>2020-11-15T15:11:34.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python笔记"><a href="#python笔记" class="headerlink" title="python笔记"></a>python笔记</h1><h2 id="重点理解记忆物理存储机制"><a href="#重点理解记忆物理存储机制" class="headerlink" title="重点理解记忆物理存储机制"></a>重点理解记忆物理存储机制</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li>开源</li><li>用C和C++写的</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>游戏：PyGame</li><li>搜索：站内搜索服务，网络爬虫</li><li>嵌入式：解决了嵌入式调试的大难题</li><li>网站后台：django/flask/tornado等诸多Web框架</li><li>C/S软件：内置Tkinter，模块，GUI编程等</li><li>脚本，自动化运维工具：诸多运维工具都已经有成熟的面向Python的接口</li><li>图像处理：PyOpenGL，Blender，Maya。人脸识别，验证码处理等</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数（int）"><a href="#整数（int）" class="headerlink" title="整数（int）"></a>整数（int）</h3><blockquote><p> 在C语言等编程语言中，一个数的大小是有上制的，这个限制取决于你计算机，例如C语言的数取决于你计算机的位数</p><p> 而python中一个数的上限取决于当前计算机的内存，不取决于计算机位数，也不取决于你定义的界限</p><p> 所以只要当前计算机的内存够大，存多少都没问题</p></blockquote><hr><h3 id="小数（float）"><a href="#小数（float）" class="headerlink" title="小数（float）"></a>小数（float）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>/<span class="number">3</span></span><br><span class="line"><span class="number">1.666666666667</span></span><br><span class="line"><span class="comment">#这里本应该是一个无穷小数，但是python做了一个精度处理</span></span><br><span class="line"><span class="comment">#这个精度长度也是又计算机内存决定的</span></span><br><span class="line"><span class="comment">#一般情况下精度都差不多，也不是一个明确固定的值</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5.0</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">5.0</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">float</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#只要有小数点，就浮点数</span></span><br></pre></td></tr></table></figure><p>type()函数用来查看当前括号中的数据类型</p><hr><h3 id="布尔（bool）"><a href="#布尔（bool）" class="headerlink" title="布尔（bool）"></a>布尔（bool）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一般说1为真，0为假是不全面的</span></span><br><span class="line">布尔：非空非<span class="number">0</span>为真，<span class="number">0</span>或空为假</span><br><span class="line">其中空在代码中一般表示为<span class="literal">None</span></span><br></pre></td></tr></table></figure><hr><h3 id="复数（complex）"><a href="#复数（complex）" class="headerlink" title="复数（complex）"></a>复数（complex）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">复数的标志为虚部以大写“J”或小写”j”结尾</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = a+<span class="number">6j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(i)</span><br><span class="line">&lt; <span class="class"><span class="keyword">class</span> &#x27;<span class="title">complex</span>&#x27;&gt;</span></span><br><span class="line">&gt;&gt;&gt; I = a+6J</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(I)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">complex</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="字符串（str）"><a href="#字符串（str）" class="headerlink" title="字符串（str）"></a>字符串（str）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"><span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params"><span class="string">&#x27;abcd&#x27;</span></span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>有些语言会把字符串和字符区分开来，而Python不对字符和字符串做区分</p><p>就像上述中的两个类型都是字符串</p><blockquote><p>字符就是单个字母的，字符串就是多个字符拼接起来的</p></blockquote><p>字符串的定义通过单引号（‘ ’）或多引号来进行定义</p><blockquote><p>这些引号个数的使用，灵活自行使用</p></blockquote><p>也可以通过   \   来防止转义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;\\n&#x27;</span>)</span><br><span class="line">\n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r&#x27;\n&#x27;</span>)</span><br><span class="line">\n</span><br></pre></td></tr></table></figure><blockquote><p>上述中print（）函数本身具备有一个换行的功能</p><p>\n   转移字符表示换行</p><p>可以通过\来进行局部的防止转义</p><p>通过  r   来进行全部的防止转义</p></blockquote><p>索引：str[index]使用index选择访问的位置，从左到右从0开始，从右到左从-1开始</p><blockquote><p>索引的前提条件是这个索引的对象是有顺序的排列的</p></blockquote><p>所以字符串是一个序列（有顺序的，是一列）</p><p>切片：str[start:stop:[step]],切片可以获取字符串上一定区间的值</p><blockquote><p>切片是左闭右开的</p><p>并且一个步长和直接不加步长是一样的，因为启示标始终停在这个切片开始的字符前面，一个步长直接就是第一个字符</p></blockquote><p>字符串其中的内容是不可变的，字符串为不可变数据对象</p><blockquote><p>当步长为负数的时候，意味着反向切片，如果切片范围为全部，则将字符串反过来</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mystr = <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mystr[::<span class="number">-1</span>])</span><br><span class="line"><span class="string">&#x27;dcba&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mystr = <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mystr[<span class="number">0</span>::<span class="number">-1</span>])</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>字符串是不可变的，所以使用索引来改变是不能改变字符串的内容的</p><hr><h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>列表中的数据类型可以是任意的，包括函数，对象名都可以，，同时是可以修改列表中的元素的。</p><blockquote><p>所以列表是有序的列表，并且是可变的</p></blockquote><p>表示方式：使用中括号，逗号分隔每个数据元素：[1,2,3,’abcd’]</p><p>列表也接受索引，切片操作</p><p>列表中的数据可以被修改，列表是可变数据对象</p><p>也可以创建一个空列表，或者只有一个元素的列表</p><p>列表会保留数据的初始状态</p><hr><h3 id="元组（tuple）"><a href="#元组（tuple）" class="headerlink" title="元组（tuple）"></a>元组（tuple）</h3><p>元组和列表类似，不同之处在于元组内数据是不可以被修改的</p><p>表示方式：元组使用小括号和逗号分隔每个数据元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;abcd&#x27;</span>) </span><br></pre></td></tr></table></figure><p>元组可以使用索引和切片操作</p><p>元组内的数据不可以被修改，所以元组为不可变数据对象</p><p>单纯的创建一个只含有一个元素的元组是会被解释器认为是一个实际数据对象，并不解释成元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(mytuple)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>这里直接会被解释器当成一个整数性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple</span><br><span class="line">(<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(mytuple)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>这里只有加逗号才会向解释器明确类型</p><p>创建只含有一个元素的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple1 = (<span class="number">1</span>)     <span class="comment"># 这个是错误的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple2 = (<span class="number">1</span>,)    <span class="comment"># 这个是正确的</span></span><br></pre></td></tr></table></figure><p>元组会保留数据的初始状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple </span><br><span class="line">()</span><br></pre></td></tr></table></figure><p>空元组会被直接创建出来</p><p>分清列表可以修改，元组不能修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple1 = (<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple2[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">会报错</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple1[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple1[<span class="number">-1</span>][<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple1[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">会报错</span><br></pre></td></tr></table></figure><p>这里面元组虽然不可以修改，但是元组里面的列表元素可以被修改</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li><p>变量不需要先定义再使用，我们可以直接给变量名赋值，直接使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myname = <span class="string">&#x27;three-pig&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myname</span><br><span class="line"><span class="string">&#x27;three-pig&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>变量可以重复存储不同种数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>可以同时为多个变量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b = <span class="string">&#x27;1&#x27;</span>,<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>变量名遵循C语言风格，变量名可以由 字母、数字、下划线 组成，数字不可以打头，大小写敏感</p></li><li><p>不支持自增、自减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a++</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>,line <span class="number">1</span></span><br><span class="line">    a++</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>++a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>--a</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>++a、–a  不报错是因为python解释器将+、-解释为正好和符号，所以++为正、–为正</p></li></ol><h3 id="变量引用计数"><a href="#变量引用计数" class="headerlink" title="变量引用计数"></a>变量引用计数</h3><p>Python中，相同数据的赋值，会共享同一片空间地址，并非占用一个新的地址单元</p><p>为了记录当前使用这个地址的变量有多少，引出了引用计数这个概念</p><p>我们可以使用del语句对一个数据的引用计数进行减1的操作，当引用计数最后为0时，这个数据占用的内存地址最终释放</p><p>我们可以使用sys模块下的getrefcount()函数进行变量引用计数的查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.getrefcount(value)</span><br></pre></td></tr></table></figure><p>这样做的好处在于可以节约内存，防止产生多余的内存碎片</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python笔记&quot;&gt;&lt;a href=&quot;#python笔记&quot; class=&quot;headerlink&quot; title=&quot;python笔记&quot;&gt;&lt;/a&gt;python笔记&lt;/h1&gt;&lt;h2 id=&quot;重点理解记忆物理存储机制&quot;&gt;&lt;a href=&quot;#重点理解记忆物理存储机制&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Markdown笔记</title>
    <link href="http://three-pigs.github.io/2020/11/15/Markdown%E7%AC%94%E8%AE%B0/"/>
    <id>http://three-pigs.github.io/2020/11/15/Markdown%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-15T15:10:06.000Z</published>
    <updated>2020-11-15T15:10:46.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown笔记（照着敲系列）"><a href="#Markdown笔记（照着敲系列）" class="headerlink" title="Markdown笔记（照着敲系列）"></a>Markdown笔记（照着敲系列）</h1><blockquote><p>所有标识符请都使用英文状态下的符号，中文大部分会不能识别</p></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 标题名（井号的个数代表标题的级数）</span><br></pre></td></tr></table></figure><h1 id="一级标题使用1个"><a href="#一级标题使用1个" class="headerlink" title="一级标题使用1个#"></a>一级标题使用1个#</h1><h2 id="二级标题使用2个"><a href="#二级标题使用2个" class="headerlink" title="二级标题使用2个#"></a>二级标题使用2个#</h2><h3 id="三级标题使用三个"><a href="#三级标题使用三个" class="headerlink" title="三级标题使用三个#"></a>三级标题使用三个#</h3><h4 id="四级标题使用4个"><a href="#四级标题使用4个" class="headerlink" title="四级标题使用4个#"></a>四级标题使用4个#</h4><h5 id="五级标题使用5个"><a href="#五级标题使用5个" class="headerlink" title="五级标题使用5个#"></a>五级标题使用5个#</h5><h6 id="六级标题使用6个"><a href="#六级标题使用6个" class="headerlink" title="六级标题使用6个#"></a>六级标题使用6个#</h6><p>最多支持六级标题</p><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~要加入删除线的对象~~   (使用英文波浪号)</span><br></pre></td></tr></table></figure><p>效果：<del>要删除的对象</del></p><hr><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*要将其变为斜体的对象*   (*后不要加空格)</span><br></pre></td></tr></table></figure><p>效果：<em>要将其变为斜体的对象</em></p><hr><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**要加粗的对象**   (两个**后不要加空格)</span><br></pre></td></tr></table></figure><p>效果：<strong>要加粗的对象</strong></p><hr><h3 id="斜体-加粗"><a href="#斜体-加粗" class="headerlink" title="斜体+加粗"></a>斜体+加粗</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***要加粗+斜体的对象***   (***后不要加空格)</span><br></pre></td></tr></table></figure><p>效果：**<em>要加粗+斜体的对象**</em></p><hr><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><blockquote><p>下划线是HTML语法</p></blockquote><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt; 需要加下划线的对象 &lt;&#x2F;U&gt;</span><br></pre></td></tr></table></figure><p>效果：<u>需要加下划线的对象</u></p><hr><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><blockquote><p>（需要勾选扩展语法）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到左上角的文件---&gt;找到偏好设置---&gt;Markdown---&gt;Markdown扩展语法---&gt;勾选高亮</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;需要加高亮的对象&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>效果：==需要加高亮的对象==</p><hr><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><blockquote><p>（需要勾选扩展语法）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到左上角的文件---&gt;找到偏好设置---&gt;Markdown---&gt;Markdown扩展语法---&gt;勾选下标</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~需要使其变为下标的对象~   (~是英文输入法状态下的)</span><br></pre></td></tr></table></figure><p>效果：<del>2</del>      整体效果：H<del>2</del>O   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中下标2的源码格式下为：~2~</span><br></pre></td></tr></table></figure><hr><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><blockquote><p>（需要勾选扩展语法）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到左上角的文件---&gt;找到偏好设置---&gt;Markdown---&gt;Markdown扩展语法---&gt;勾选上标</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^需要使其变为上标的对象^</span><br></pre></td></tr></table></figure><p>效果：^2^     整体效果：m^2^</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中上标2的源码格式为：^2^</span><br></pre></td></tr></table></figure><hr><h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><blockquote><p>这里支持使用一些emoji符号，emoji符号就像QQ、微信中一开始自带的表情符号差不多</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:一些对应符号的关键字:   (:需要使用英文)</span><br></pre></td></tr></table></figure><p>效果：:smile:</p><blockquote><p>下面是一些符号的关键字</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary:</span><br><span class="line"></span><br><span class="line">:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</span><br></pre></td></tr></table></figure><p>:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary:</p><p>:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>相邻两个单元格之间使用<code>|</code>来进行分隔，使用<code>-</code>来分隔标头和其他行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name | price</span><br><span class="line">--- | ---</span><br><span class="line">friend chicken | 19</span><br><span class="line">cola | 5</span><br></pre></td></tr></table></figure><blockquote><p>为了使Markdown更清晰，<code>|</code>和<code>-</code>两侧需要至少有一个空格（最左侧和最外侧的<code>|</code>为了减少代码量就不需要写了）</p></blockquote><p>如果为了美观，可以使用空格来对齐不同杭的单元格，并在左右两侧都使用<code>|</code>来标记单元格的边界，在表头下方的分隔线标记中加入<code>:</code>,即可标记下方单元格内容的对齐方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|    name       | price |</span><br><span class="line">| :------------ | :---: |</span><br><span class="line">| fried chicken | 19    |</span><br><span class="line">| cola          |  32   |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th align="left">name</th><th align="center">price</th></tr></thead><tbody><tr><td align="left">fried chicken</td><td align="center">19</td></tr><tr><td align="left">cola</td><td align="center">32</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据上面事例中表头下方的分隔线中的“：”可以看出，</span><br><span class="line">:------            (内容向左对齐)</span><br><span class="line">------:            (内容向右对齐)</span><br><span class="line">:------:           (内容居中对齐)</span><br><span class="line">即引号偏向哪，就往哪对齐</span><br></pre></td></tr></table></figure><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>引用主要是为了引用别人的话等等，但是我喜欢怎么爽怎么来，好看就行，所以就不遵循了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 需要引用的对象</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>你好</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 也可以在引用中</span><br><span class="line">&gt;&gt; 使用嵌套的引用</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>也可以在引用中</p><blockquote><p>使用嵌套的使用</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在编写过程中如果想退出这个引用，开启下一行不是引用的段落或者开启下一个引用，</span><br><span class="line">可以使用键盘上的向下移动键，</span><br><span class="line">如果想在原先的引用中嵌套，</span><br><span class="line">可以直接回车，它还会在这个引用中，</span><br><span class="line">之后可以再来一个  &gt;  来嵌套另一个引用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(我一般&gt;打出来后直接加空格，个人习惯，也可以不加空格)</span><br></pre></td></tr></table></figure><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 可以使用 &#39;*&#39; 作为标记    (*后面加个空格)</span><br><span class="line">+ 也可以使用&#39;+&#39;           (+后面加个空格)</span><br><span class="line">- 或者&#39;-&#39;                (-后面加个空格)</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>可以使用 ‘*’ 作为标记</li><li>也可以使用’+’</li><li>或者’-‘</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方向键的向下移动键来退出这个无序列表模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一般我使用  *   </span><br><span class="line">因为里面有很多共用，好记</span><br></pre></td></tr></table></figure><hr><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表以数字和 &#96;.&#96; 开始；</span><br><span class="line">3. 数字的序列并不会影响生成的列表序列；</span><br><span class="line">4. 但仍然推荐按照自然顺序（1.2.3...）编写。</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>有序列表以数字和<code>.</code>开始；</li><li>数字的序列并不会影响生成的列表序列；</li><li>但仍然推荐按照自然顺序（1.2.3…）编写。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以使用：数字\. 来取消显示为列表(用反斜杠进行转义)</span><br><span class="line">1\. 这个不会生成有序列表</span><br></pre></td></tr></table></figure><p>效果：</p><p>可以使用：数字. 来取消显示为列表(用反斜杠进行转义)<br>1. 这个不会生成有序列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方向键的向下移动键来退出这个有序列表模式</span><br></pre></td></tr></table></figure><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;(语言名称)</span><br></pre></td></tr></table></figure><blockquote><p>上面的语言名称可写可不写，写了会根据指定语言来显示指定代码的高量，不写里面什么标识符都不会识别，就像上方的事例中效果上的代码和下方的代码是一样的，但是效果的上面那个因为在代码块中是不会执行代码的，所以可以和效果中的形成对比</p></blockquote><p>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也可以通过 &#96;&#96;，插入行内代码(&#96; 是 &#96;Tab&#96; 键上边、数字 &#96;1&#96; 键左侧的那个按键)</span><br><span class="line"></span><br><span class="line">例如 &#96;Markdown&#96;</span><br></pre></td></tr></table></figure><p>效果：</p><p>也可以通过 ``，插入行内代码(<code>是</code>Tab<code>键上边、数字</code>1` 键左侧的那个按键)</p><p>例如 <code>Markdown</code></p><h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p>代码块中的文本（包括Markdown语法）都会显示为原始内容</p><hr><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><blockquote><p>可以在一行中使用三个或更多的<code>*</code>、<code>-</code>、<code>_</code>来添加分割线</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---------</span><br><span class="line">_______</span><br></pre></td></tr></table></figure><p>效果：</p><hr><hr><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一般我使用***或更多的*来添加分割线，因为*和之前的加粗斜体、无序列表都是使用*，好记</span><br><span class="line"></span><br><span class="line">分割线会占一整行，所以这个行内如果有其他符号，不会识别</span><br></pre></td></tr></table></figure><hr><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><h4 id="外部跳转–超链接"><a href="#外部跳转–超链接" class="headerlink" title="外部跳转–超链接"></a>外部跳转–超链接</h4><p>格式为<code>[link text](link)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[帮助文档](https:&#x2F;&#x2F;support.typora.io&#x2F;Links&#x2F;#faq)</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https://support.typora.io/Links/#faq">帮助文档</a></p><hr><h4 id="内部跳转–本文件内跳（Typora支持）"><a href="#内部跳转–本文件内跳（Typora支持）" class="headerlink" title="内部跳转–本文件内跳（Typora支持）"></a>内部跳转–本文件内跳（Typora支持）</h4><p>格式为<code>[link text](#要去的目的地--标题)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[我想跳转](#高亮)</span><br></pre></td></tr></table></figure><blockquote><p>Open Links in Typora</p><p>You can use <code>command+click</code> (macOS), or <code>ctrl+click</code> (Linux/Windows) on links in Typora to jump to target headings, or open them in Typora, or open in related apps.</p><p>这是官方文档中的帮助</p></blockquote><p>效果：</p><p><a href="#%E9%AB%98%E4%BA%AE">我想跳转</a></p><hr><h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p>使用<code>&lt;&gt;</code>包括的URL或者邮箱地址会被自动转换为超链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:&#x2F;&#x2F;www.baidu.com&gt;</span><br><span class="line"></span><br><span class="line">&lt;123@email.com&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p><p><a href="mailto:&#x31;&#x32;&#x33;&#64;&#x65;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;">&#x31;&#x32;&#x33;&#64;&#x65;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;</a></p><hr><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![自己起的图片名字](图片地址或者图片本地存储的路径)</span><br></pre></td></tr></table></figure><h4 id="网上的图片"><a href="#网上的图片" class="headerlink" title="网上的图片"></a>网上的图片</h4><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Minions](https:&#x2F;&#x2F;timgsa.baidu.com&#x2F;timg?image&amp;quality&#x3D;80&amp;size&#x3D;b9999_10000&amp;sec&#x3D;1602358537068&amp;di&#x3D;1ab36a09f4f931891b65624fdd02b9c9&amp;imgtype&#x3D;0&amp;src&#x3D;http%3A%2F%2Fattach.bbs.miui.com%2Fforum%2F201312%2F27%2F104503vziu5p296aw6z6m6.jpg)</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1602358537068&di=1ab36a09f4f931891b65624fdd02b9c9&imgtype=0&src=http://attach.bbs.miui.com/forum/201312/27/104503vziu5p296aw6z6m6.jpg" alt="Minions"></p><hr><h4 id="本地路径"><a href="#本地路径" class="headerlink" title="本地路径"></a>本地路径</h4><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Minions](.&#x2F;images&#x2F;Minions.jpg)</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="./images/Minions.jpg" alt="Minions"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown笔记（照着敲系列）&quot;&gt;&lt;a href=&quot;#Markdown笔记（照着敲系列）&quot; class=&quot;headerlink&quot; title=&quot;Markdown笔记（照着敲系列）&quot;&gt;&lt;/a&gt;Markdown笔记（照着敲系列）&lt;/h1&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux笔记</title>
    <link href="http://three-pigs.github.io/2020/11/15/linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://three-pigs.github.io/2020/11/15/linux%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-15T15:06:54.000Z</published>
    <updated>2020-11-15T15:08:55.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要背的目录文件"><a href="#要背的目录文件" class="headerlink" title="要背的目录文件"></a>要背的目录文件</h2><ol><li>安装后的三个文件</li><li>牢记</li><li>搜索命令中locate中的数据库位置 /var/lib/mlocate/mlocate.db</li></ol><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><blockquote><p>格式化（高级格式化）又称为逻辑格式化，它是指根据用户选定的文件系统（如FAT16、FAT32、NTFS、EXT2、EXT3、EXT4等），在磁盘的特定区域写入特定的数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。</p><ul><li>在RedHat6中使用的是EXT4</li><li>在RedHat7中使用的是XFS</li><li>在Windows中一般使用NTFS</li></ul></blockquote><p>格式化可以理解为在柜子上打隔断（格式化针对的是分区！）</p><blockquote><p>将一个分区分为两个部分：一个小空间用来存放Inode(I节点)，一个用来存放block（数据块）</p><ul><li><p>Inode：一般是128B,Inode=Inode号+时间+文件权限+保存位置</p><blockquote><ul><li>一般每个文件都会有Inode，只有极少数没有</li><li>Inode区在格式化时便划分了一定区域，是有大小的， Inode区有可能被写满，一般如果空文件存的多了，空文件不占用block区，但是依旧会占用Inode区，每个文件都会有一个Inode号,当Inode区被写满的时候，是不能在网硬盘里写东西的，所以尽力不要大量的存储空文件，同时也要考虑到其他人通过脚本循环来无限创建新文件，写满硬盘的Inode区，使硬盘无法存储。</li></ul></blockquote></li><li><p>block：一般是4KB,在linux下可以是2KB或1KB</p><blockquote><ul><li>计算机将数据存在block中，一个文件的每个block数据块不一定是连续的，有可能是分开的</li><li>数据存储在block数据块中的时候，由于一般block数据块是4KB,所有当文件的大小为奇数时，注定最少有一个block数据块不能放满，但这个block中只能存放一个数据，所以会有所空缺,以至于有些文件的大小与它硬盘存储的空间是不一样的。</li><li>Windows中有些工具可以整理文件的block,来提高硬盘的读取速度</li></ul></blockquote></li></ul></blockquote><p>注：格式化的目的是为了写入文件系统，不是为了清楚数据！！！</p><hr><h3 id="两种分区表形式"><a href="#两种分区表形式" class="headerlink" title="两种分区表形式"></a>两种分区表形式</h3><ol><li><p>MBR分区表：最大支持2.1TB硬盘，最多支持四个分区</p><blockquote><ul><li><p>主分区：最多只能有4个。</p></li><li><p>扩展分区：</p><blockquote><p>最多只能有一个。</p><p>主分区加扩展分区最多有4个。</p><p>不能写入数据，只能包含逻辑分区</p></blockquote></li><li><p>逻辑分区</p></li></ul></blockquote><ul><li>当一个硬盘容量大于2.1T的时候，此MBR分区形式便只会读取那2.1T，后面剩余的容量便不会再读取 </li><li>此分区表形式现在大部分还在使用，如windows中的分区，一般只会分四个区，前三个是主分区，第一个一般是C盘（系统盘），后两个主分区，再后面的分区因为MBR分区表的限制只能分四个分区，所以一般第四个会设置为扩展分区，在这个扩展分区中在创建多个逻辑分区。</li></ul></li><li><p>GPT分区表（全局唯一标示分区表）：GPT支持9.4ZB硬盘（1ZB=1024PB,1PB=1024EB,1EB=1024TB）。理论上支持的分区数没有限制，但windows限制128个主分区</p></li></ol><hr><h3 id="硬件设备文件名"><a href="#硬件设备文件名" class="headerlink" title="硬件设备文件名"></a>硬件设备文件名</h3><table><thead><tr><th align="center">硬件</th><th align="center">设备文件名</th></tr></thead><tbody><tr><td align="center">IDE硬盘</td><td align="center">/dev/hd[a-d]</td></tr><tr><td align="center">SCSI/SATA/USB硬盘</td><td align="center">/dev/sd[a-p]</td></tr><tr><td align="center">光驱</td><td align="center">/dev/cdrom或/dev/sr0</td></tr><tr><td align="center">软盘</td><td align="center">/dev/fd[0-1]</td></tr><tr><td align="center">打印机（25针）</td><td align="center">/dev/lp[0-2]</td></tr><tr><td align="center">打印机（USB）</td><td align="center">/dev/usb/lp[0-15]</td></tr><tr><td align="center">鼠标</td><td align="center">/dev/mouse</td></tr></tbody></table><blockquote><ul><li><p>设备文件名</p><blockquote><ol><li><p>/dev/hda1（IDE硬盘接口）</p></li><li><p>/dev/sda1（SCSI硬盘接口、SATA硬盘接口、usb硬盘接口）</p><blockquote><ul><li>对于sda1,其中s指的是SCSI、SATA、usb的接口，a表示第一块硬盘如果是b表示第二块硬盘、1表示第一个分区</li><li>如果是sdb5,这个指的是第二块硬盘的逻辑分区，因为MBR分区格式为最多四个分区，三个主分区，一个扩展分区，其中扩展分区中分逻辑分区。</li><li>设备一般会被自动识别</li></ul></blockquote></li></ol></blockquote></li></ul></blockquote><hr><h3 id="挂载点"><a href="#挂载点" class="headerlink" title="挂载点"></a>挂载点</h3><ul><li>使用已经存在的空目录作为挂载点,所有的空目录，包括新建目录都可以作为挂载点，但是/bin/、/lib/、/etc/除外，必须和根目录在同一目录下，因为里面包含了系统所需要的文件，单独分出来会出现问题</li><li>挂载是一个动作，挂载点是一个位置，是进入这个分区访问数据的入口</li></ul><hr><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载是将硬件设备名与空目录相连接</p><ul><li><p>必须分区</p><blockquote><p>/（根分区）</p><blockquote><ul><li>是Linux的最高一级目录</li><li>如果不分，这个里面的数据是没有地方存的</li><li>安装之前，整块硬盘都是空的，所以安装的时候就已经好分了</li></ul></blockquote><p>swap分区（交换分区）</p><blockquote><ul><li>如果真实内存小于4GB,swap位内存的两倍</li><li>如果真实内存大小大于4GB,swap和内存一致</li><li>实验环境，不大于2GB</li><li>将硬盘划分一个独立的分区，此swap分区被内核来调用</li><li>可以当作计算机虚拟内存来对待</li><li>不分会报错，但是还是可以进行操作，是应为linux机制的问题</li></ul></blockquote></blockquote></li><li><p>推荐分区</p><blockquote><p>/boot（启动分区，1GB）</p><blockquote><p>不论是Windows还是Linux，在系统启动时都会释放一部分临时空间，有一些临时文件、压缩文件要释放，如果这些文件释放不了，那么系统就无法启动。</p><ul><li>所以如果在没有分/boot分区的情况下，如果硬盘被写满，那么这些临时文件便释放不了，会导致系统无法开机。</li><li>/boot不用太大 。<ul><li>RedHat7要求1GB</li><li>RedHat6要求200MB</li></ul></li></ul></blockquote></blockquote></li><li><p>常用分区</p><blockquote><p>/home（用于文件服务器）</p><p>/www（用于Web服务器）</p></blockquote></li></ul><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>建议修改主机名,不然使用Linux默认的主机名当到了集群之后很难分辨哪个是哪个</p></li><li><p>密码三原则:</p><blockquote><ul><li>复杂性:<ul><li>大于8位</li><li>大写、小写、数字、符号四种最少包含三种</li><li>不允许使用和个人信息相关的内容</li><li>不允许使用现有的英文单词</li></ul></li><li>易记忆性:</li><li>时效性:</li></ul></blockquote></li><li><p>swap分区没有挂载点:</p><blockquote><p>swap分区是给Linux内核直接访问的，不是让用户访问的，而挂载点是用户进入访问硬盘的接口,所以swap分区不需要这个接口。</p></blockquote></li><li><p>现在一般分区表格式是MBR,所以只能有三个主分区，之后便是扩展分区中的逻辑分区</p></li><li><p>在Arch Linux安装时，一般是使用GPT分区表格式，不需要考虑分区个数问题</p></li><li><p>服务器坚决不安装图形化界面！！！</p></li></ul><hr><h3 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h3><ol><li><p>通过setup工具设置IP地址，注意激活onboot=yes</p><blockquote><ul><li>这个工具只有RedHat系列有</li><li>到RedHat7开始，基本开始使用nmtui工具来配置</li><li>RedHat6以前的系统当中，网卡都是通过eth0来命名的</li><li>RedHat7之后，网卡开始使用eno+网卡的随即编码来命名</li><li>不激活onboot,根本不会查询到此网卡</li></ul></blockquote></li><li><p>通过修改配置文件配置</p></li><li><p>重启网络服务：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure></blockquote></li><li><p>查询IP地址：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>Linux中用来查询IP地址等信息</p></blockquote><ul><li>网卡名为  lo  ：<ul><li>这个是 Local Loopback    ,是本地回环网卡</li><li>IP地址为：127.0.0.1</li><li>哪怕不插网线也能ping通，ping通代表自己的网络协议是正常的</li></ul></li></ul></li><li><p>虚拟机中的物理网卡配置</p><table><thead><tr><th>连接方式</th><th align="center">连接网卡</th><th align="center">是否能连接本机</th><th align="center">是否能连接局域网</th><th align="center">是否能连接公网</th></tr></thead><tbody><tr><td>桥接</td><td align="center">本地真实网卡</td><td align="center">可以</td><td align="center">可以</td><td align="center">可以</td></tr><tr><td>NAT</td><td align="center">VMnet8</td><td align="center">可以</td><td align="center">不能</td><td align="center">可以</td></tr><tr><td>仅主机</td><td align="center">VMnet1</td><td align="center">可以</td><td align="center">不能</td><td align="center">不能</td></tr></tbody></table><ul><li><p>桥接:</p><blockquote><ul><li>会占用真实网段的一个IP,可能会引起IP冲突</li><li>限制最少</li><li>需要频繁更换地方的时候需要不停的更改本机的IP和桥接所使用的IP，很麻烦</li><li>最好桥接到有限网卡</li></ul></blockquote></li><li><p>NAT:</p><blockquote><ul><li>VMnet8会随机直接生成一个随机的网段，不会和本机网段相同</li><li>不能连接局域网</li><li>真实机能连接公网，那么虚拟机也可以连接公网</li></ul></blockquote></li><li><p>远程管理工具</p><blockquote><ul><li>xshell:<ul><li>免费</li><li>建议使用</li></ul></li><li>SCTR:<ul><li>发展较早</li><li>收费</li></ul></li></ul></blockquote></li><li><p>Windows和Linux之间传输文件工具:</p><blockquote><ul><li>WinSCP:<ul><li>使用的是ssh文件传输协议，是Linux自带的安全远程管理工具</li></ul></li></ul></blockquote></li></ul></li></ol><hr><h3 id="安装后的三个文件"><a href="#安装后的三个文件" class="headerlink" title="安装后的三个文件:"></a>安装后的三个文件:</h3><ol><li><p>/root/install.log</p><blockquote><ul><li>存储了安装在系统中的软件包及其版本信息</li></ul></blockquote></li><li><p>/root/install.log.syslog</p><blockquote><ul><li>存储了安装过程中留下的事件记录</li></ul></blockquote></li><li><p>/root/anaconda-ks.cfg</p><blockquote><ul><li>以Kickstart配置文件的格式记录安装过程中设置的选项信息</li><li>记录了从开始安装到现在的所有操作步骤信息</li><li>主要用于服务器的批量安装</li><li>每一个单独安装的Linux都会生成这个安装模板文件</li></ul></blockquote></li></ol><h2 id="开始前的牢记事项"><a href="#开始前的牢记事项" class="headerlink" title="开始前的牢记事项"></a>开始前的牢记事项</h2><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>Linux严格区分大小写</p><blockquote><ul><li>命令是没有大写的</li><li>选项有大小写</li></ul></blockquote></li><li><p>Linux一切皆文件</p><blockquote><ul><li>Linux中所有内容都是以文件的形式保存和管理的，硬件设备也是文件，这和Windows完全不同，Windows是通过设备管理器来管理硬件的。Linux的设备文件保存在/dev/目录中，硬盘文件是/dev/sd[a-p]，光盘文件是/dev/hdc等。</li><li>所有的配置只有写到对应的配置文件，才会永久生效，否则只有配置的时候生效，重启不会生效</li></ul></blockquote></li><li><p>Linux不靠扩展名来区分文件类型</p><blockquote><ul><li><p>Windows是依赖扩展名区分文件类型的，比如，“.txt”是文本文件、“.exe”是执行文件、“.ini”是配置文件、“.mp4”视频等。但Linux不是靠扩展名区分文件类型的，而是靠权限位标识来确定文件类型的，而且文件类型的种类也不像Windows下那么多，常见的文件类型只有普通文件、目录、链接文件、块设备文件、字符设备文件等几种。Linux的可执行文件不过就是普通文件被赋予了可执行权限而已。</p></li><li><p>但Linux中的一些特殊文件还是要求写“扩展名”的，但是大家小心，并不是Linux一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有以下几种：</p><blockquote><ul><li>压缩包：Linux下的常见压缩文件名有 “.gz”、”.bz2”、”.zip”、”.tar.gz”、”.tar.bz2”、”.tgz”等。压缩包写扩展名是为了让管理员能够容易判断出这个文件是压缩包的格式，虽然后命令可以帮助判断，但是直观一点更加方便。另外，就算没写扩展名，在Linux中一样可以解压，不影响使用。</li><li>二进制软件包：CentOS中所使用的二进制 安装包是RPM包，所有的RPM包都是用“.rpm”扩展名结尾，目的同样是让管理员一目了然。</li><li>程序文件：shell脚本一般使用“.sh”扩展名结尾，其他还有用“.c”扩展名结尾的C语言文件等。</li><li>网页文件：网页文件一般使用“.html”“.php”等结尾，不过这是网页服务器的要求，而不是Linux的要求。</li></ul></blockquote></li></ul></blockquote></li><li><p>Linux中所有的存储设备都必须在挂载之后才能使用</p><blockquote><ul><li>Linux中所有存储设备都有自己的设备文件名，这些设备文件必须在挂载之后才能使用，包括硬盘、U盘和光盘。把设备文件（如/dev/sdb）和挂载点（已经建立的空目录）连接的过程叫做挂载</li><li>在安装之后，硬盘基本都是开机自动挂载，想U盘和光盘这类的移动存储设备需要手动挂载</li><li>当然可以设置自动挂载，但是如果将U盘这些移动设备设置为自动挂载，由于Linux是完全信任管理员的，所以在开机时会检测U盘这类移动设备，如果检测不到会导致死机，虽然修复很容易，但是如果使用的是服务器，是需要对真实机进行操作的，如果距离很远，得不偿失。</li><li>有挂载就有卸载，就像Windows中的U盘安全弹出，如果不安全弹出，有可能会导致传输的数据丢失，所以最好挂载使用之后在进行一便卸载。</li></ul></blockquote></li><li><p>Windows下的程序不能直接在Linux中使用</p><blockquote><ul><li>有很多软件都有Linux相应的版本</li><li>可以通过模拟器来进行一些软件的使用</li></ul></blockquote></li></ol><hr><h3 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h3><h4 id="牢记"><a href="#牢记" class="headerlink" title="牢记"></a>牢记</h4><ol><li><p>Linux目录结构</p><table><thead><tr><th>目录名</th><th>目录的作用</th></tr></thead><tbody><tr><td>/bin/</td><td>存放系统命令的目录，普通用户和超级用户都可以执行。是/usr/bin/目录的软链接</td></tr><tr><td>/sbin/</td><td>存放系统命令的目录，只有超级用户才可以执行。是/usr/sbin/目录的软链接</td></tr><tr><td>/usr/bin/</td><td>存放系统命令的目录，普通用户和超级用户都可以执行</td></tr><tr><td>/usr/sbin/</td><td>存放系统命令的目录，只有超级用户才可以执行</td></tr><tr><td>/boot/</td><td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub5）</td></tr></tbody></table><blockquote><ul><li>bin是binary的缩写，翻译为二进制</li></ul></blockquote></li><li><p>一级目录结构</p><table><thead><tr><th>目录名</th><th>目录的作用</th></tr></thead><tbody><tr><td>/dev/</td><td>设备文件保存位置</td></tr><tr><td>/etc/</td><td>配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td></tr><tr><td>/home/</td><td>普通用户的家目录。在创建用户时，每个用户要有一个默认登陆和保存自己数据的位置，就是用户的家目录，所有普通用户的宿主目录是在/home/下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1/</td></tr><tr><td>/lib/</td><td>系统调用的函数库保存位置。是/usr/lib的软链接</td></tr><tr><td>/lib64/</td><td>64位函数库保存位置。是/usr/lib64的软链接</td></tr><tr><td>/lost+found/</td><td>当系统意外崩溃或者机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found 就是跟分区的备份恢复目录，/boot/lost+found 就是/boot 分区的备份恢复目录</td></tr><tr><td>/media/</td><td>挂载目录。系统建议是用来挂载媒体设备的，如软盘和光盘</td></tr><tr><td>/misc/</td><td>挂载目录。系统建议用来挂载NFS服务的共享目录。</td></tr><tr><td>/mnt/</td><td>挂载目录。早期Linux中只有这一个挂载目录，并没有细分。现在系统建议这个目录用来挂载额外设备，如 U 盘、移动硬盘和其他操作系统的分区</td></tr><tr><td>/opt/</td><td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中</td></tr><tr><td>/proc/</td><td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo 是保存CPU信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的…….</td></tr><tr><td>/sys/</td><td>虚拟文件系统，和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td></tr><tr><td>/root/</td><td>root的宿主目录。普通用户宿主目录在/home/下，root 宿主目录直接在“/”下</td></tr><tr><td>/run/</td><td>系统运行时产生的数据，如ssid,pid 等相关数据。/var/run/是此目录的软链接</td></tr><tr><td>/srv/</td><td>服务数据目录。一些系统服务启动后，可以在这个目录中保存所需要的数据</td></tr><tr><td>/tmp/</td><td>临时目录。系统存放临时文件的目录，该目录下，所有用户都可以访问和写入。建议此目录不能保存重要数据，最好每次开机都把该目录清空</td></tr><tr><td>/usr/</td><td>系统软件资源目录。注意usr不是user的缩写，而是“UNIX Software Resource”的缩写，所以不是存放在用户数据的目录，而是存放系统软件资源的目录，系统中安装的软件大多数保存在这里</td></tr><tr><td>selinux</td><td>增强linux安全组建的东西，用来限制root的权限</td></tr><tr><td>/var/</td><td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td></tr></tbody></table><blockquote><ul><li>在Linux下，颜色越鲜艳，文件重要性越高</li><li>由于Linux很早就有了，行业里面接触的时候，默认挂载目录只有 /mnt 一个，所以行业里一般都会有在 /mnt  下建立不同目录挂载不同设备的习惯。如 /mnt/cdrom 挂载光盘，/mnt/usb  挂载U盘，这都是可以的。</li><li>行业里还是习惯把软件放到/usr/local 目录中，也就是说，/usr/local目录也是可以用来安装软件的</li><li>Linux中只要以“.so+数字”结尾，这个文件便是系统函数</li></ul></blockquote></li><li><p>二级目录结构</p><table><thead><tr><th>目录</th><th>目录的作用</th></tr></thead><tbody><tr><td>/usr/lib/</td><td>应用程序调用的函数库保存位置</td></tr><tr><td>/usr/local/</td><td>手工安装的软件保存位置，一般建议源码包软件安装在这个位置</td></tr><tr><td>/usr/share/</td><td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td></tr><tr><td>/usr/src/</td><td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过业内更习惯将手工下载的源码包保存到/usr/local/src/ 目录中，把内核源码保存到/usr/src/kernels/目录中</td></tr><tr><td>/usr/src/kernels/</td><td>内核源码保存位置</td></tr><tr><td>/var/www/html/</td><td>RPM包安装的Apache的网页主目录</td></tr><tr><td>/var/lib/</td><td>程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在/var/lib/mysql/目录中</td></tr><tr><td>/var/log/</td><td>系统日志保存位置</td></tr><tr><td>/var/run/</td><td>一些服务和程序运行后，它们的PID（进程ID）保存位置。是/run/目录的软链接</td></tr><tr><td>/var/spool/</td><td>放置队列数据的目录。就是排队等带其他程序使用的数据，比如邮件队列和打印队列</td></tr><tr><td>/var/spool/mail/</td><td>新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录中</td></tr><tr><td>/var/spool/cron/</td><td>系统的定时任务队列保存位置。系统的计划人物会保存在这里</td></tr></tbody></table><blockquote><ul><li>src的意思是源代码、源码包，是source code 的缩写</li></ul></blockquote></li></ol><h4 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a>重要注意事项</h4><ol><li><p>远程服务器关机及重启时的注意事项</p><p>服务器不能关机，只能重启</p><blockquote><ul><li><p>远程服务器在重启前，要终止正在执行的服务</p><blockquote><p>计算机的硬盘最害怕在高速存储时断点或重启，非常容易造成硬盘损坏。所以，在重启前先终止你的服务，甚至可以考虑暂时断开对外提供服务的网络，但是也不要把自己给断了，那为什么在日常生活中，使用我们个人的电脑，经常强制关机，也没有发现硬盘损坏，那是因为你的个人计算机没有很多人访问，强制断电时硬盘并没有进行数据交换，小心驶得万年船！</p></blockquote></li><li><p>重启命令的选用</p><blockquote><p>Linux可以识别的命令有很多条，但是建议使用“ shutdown -r now ”命令重启，这条命令在重启时会正常保存和终止服务器中正在运行的程序，是安全重启命令，而且最好在重启前执行几次“ sync ”命令，这条命令是数据同步命令，可以让暂时保存在内存中的数据同步到硬盘上。</p></blockquote></li><li><p>不要在服务器访问高峰运行高负载命令</p><blockquote><p>在服务器访问高峰，如果使用一些对服务器压力较大的命令，则有可能会造成服务器响应缓慢甚至死机。</p><p>对于命令会造成高负载。其实，和Windows操作系统差不多，如复制大量的数据、压缩或者解压大文件、大范围的硬盘搜索等</p><p>什么时候算是访问访问高峰期？一般认为17：00——24:00算作访问高峰期。当然，每台服务器具体提供的服务不同，访问高峰期又是也会有所出入。比如，服务器主要是供美国人民访问的，那就要考虑时差的问题；或者服务器提供的服务很特殊，访问高峰期也可能不同。</p><p>一般我们建议在凌晨4：00——5：00执行这些命令。那是不是说我们需要在凌晨上班？当然不是，我们可以使用系统的计划任务，让操作自动在指定的时间段执行。</p></blockquote></li><li><p>远程配置防火墙时不要把自己踢出服务器</p><blockquote><p>简单来讲，防火墙就是根据数据包自身的参数来判断是否允许数据包通过的网络设备。我们的服务器想要在公网中安全的使用，就需要使用防火墙过滤有害的数据包。但是在配置防火墙时，如果管理员对防火墙不是很熟悉，则有可能把自己的正常访问数据包和有害数据包全部过滤掉，导致自己也无法正常登陆服务器，如防火墙关闭了远程连接的SSH服务的端口。</p><p>防火墙配置完全是靠手工命令完成的，配置规则和配置命令相对也比较复杂，万一设置的时候心不在焉，悲剧就发生了</p><p>如何避免这种尴尬的情况发生？最好的办法就是在服务器本地配置防火墙，这样就算不小心把自己的远程登陆给过滤了，还可以通过本机登陆来进行修复。如果服务器已经在远程登陆了，要配置防火墙，那么最好在本地测试完善后再进行上传，这样会把发生故障的几率降到最低。虽然在本地测试好了，但是传到远程服务器上时仍有可能发生问题。于是有一个笨方法，如果需要远程配置防火墙，那么先写一个系统定时任务，让它每5分钟清空一下防火墙规则，就算写错了也还有反悔的机会，等配置完了再将这个规则清除</p></blockquote><ul><li><p>防火墙：</p><blockquote><p>基本功能是数据包过滤（IP、MAC地址、端口号、协议类型、数据包中数据）</p></blockquote></li></ul></li></ul></blockquote></li><li><p>指定合理的密码规范并定期更新</p><blockquote><p>设置密码要遵守复杂性、易记忆性和时效性的三原则</p></blockquote></li><li><p>合理分配权限</p><blockquote><p>服务器管理有一个最简单的原则：给予用户最小的权限</p></blockquote></li><li><p>定期备份重要数据和日志</p><blockquote><p>备份的基本原则：不要把鸡蛋放在同一个篮子里</p></blockquote></li></ol><hr><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="命令的基本格式"><a href="#命令的基本格式" class="headerlink" title="命令的基本格式"></a>命令的基本格式</h3><ol><li><p>命令的提示符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#</span><br><span class="line">[root@localhost ~]# hostname</span><br><span class="line">localhost.localdomain</span><br></pre></td></tr></table></figure><blockquote><ul><li>[]：这是提示符的分隔符，没有特殊含义</li><li>root：显示的是当前登陆用户，现在使用的是root用户登陆</li><li>@：分隔符号，没有特殊含义</li><li>localhost：当前系统的简写主机名（完整主机名是localhost.localdomain）</li><li>～：代表用户当前所在的目录，此例中用户当前所在的目录是家目录</li><li>#：命令提示符。超级用户是#，普通用户是$</li></ul></blockquote></li><li><p>命令的基本格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# 命令 [选项] [参数]</span><br></pre></td></tr></table></figure><blockquote><p>基本所有带[]的意思是可选项，可加可不加</p><p>ls是最常见的目录操作命令，主要作用是显示目录下的内容。</p><ul><li><p>命令名称：ls</p></li><li><p>英文原意：list</p></li><li><p>所在路径：/bin/ls</p></li><li><p>执行权限：所有用户</p></li><li><p>功能描述：显示目录下的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">总用量 44</span><br><span class="line">-rw------. 1 root root 1207 1月 14 10:10 anaconda.cfg</span><br></pre></td></tr></table></figure><ul><li>第一列：权限。</li><li>第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录（包括了隐藏目录）</li><li>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户</li><li>第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li><li>第五列：大小。默认单位是字节。</li><li>第六列：文件修改时间。文件状态修改时间或文件修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li><li>第七列：文件名。</li></ul></li></ul></blockquote></li></ol><hr><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="目录命令"><a href="#目录命令" class="headerlink" title="目录命令"></a>目录命令</h4><ol><li><p>cd命令</p><blockquote><ul><li>命令名称：cd</li><li>英文原意：change directory</li><li>所在路径：Shell内置命令</li><li>执行权限：所有用户</li></ul><p>功能描述：切换所在目录</p></blockquote><p>cd命令的简化用法</p><table><thead><tr><th>特殊符号</th><th>作用</th></tr></thead><tbody><tr><td>～</td><td>代表用户的家目录</td></tr><tr><td>-</td><td>代表上次所在目录</td></tr><tr><td>.</td><td>代表当前目录</td></tr><tr><td>..</td><td>代表上级目录</td></tr></tbody></table><blockquote><ul><li>绝对路径和相对路径<ul><li>绝对路径：以跟目录为参照物，从跟目录开始，一级一级进入目录</li><li>相对路径：以但前目录作为参照物，进行目录查找</li></ul></li></ul></blockquote></li><li><p>mkdir命令</p><blockquote><p>mkdir是创建目录的命令</p><ul><li>命令名称：mkdir</li><li>英文原意：make directories</li><li>所在路径：/bin/mkdir</li><li>执行权限：所有用户</li><li>功能描述：创建空目录</li></ul><hr><p>选项:</p><ul><li>-p             递归创建所需目录</li></ul><hr><p>注意：</p><ul><li>创建的目录和当前目录中的文件或者目录不能重名，所有操作系统都一样，同意目录下，不能有相同名字的文件和目录。<ul><li>Windows中是因为文件扩展名的原因，而Linux没有扩展名这一说</li></ul></li></ul></blockquote></li><li><p>rmdir命令</p><p>是删除空目录的意思，不常用，一般使用rm命令</p></li></ol><hr><h4 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h4><ol><li><p>touch命令</p><blockquote><p>创建空文件或修改文件时间</p><ul><li>命令名称：touch</li><li>英文原意：change file timestamps</li><li>所在路径：/bin/touch</li><li>执行权限：所有用户</li><li>功能描述：修改文件的时间戳</li></ul><hr><ol><li><p>注意：</p><p>在同一目录下，如果已经有一个文件，在touch一个和这个文件重名的文件不会报错，它会修改这个文件的修改时间</p><p>！！！  touch不是创建文件，只是有创建文件的功能   ！！！</p></li></ol></blockquote><p>stat命令</p><blockquote><p>stat是查看文件详细信息</p><ul><li>命令名称：stat</li><li>英文原意：display file or file system status</li><li>所在路径：/usr/bin/stat</li><li>执行权限：所有用户</li><li>功能描述：显示文件或文件系统的详细信息</li></ul><hr><p>详细解读自行百度</p></blockquote></li><li><p>cat命令</p><blockquote><p>cat命令用来查看文件内容</p><ul><li>英文名称：cat</li><li>英文原意：concatenate files and print on the standard output </li><li>所在路径：/bin/cat</li><li>执行权限：所有用户</li><li>功能描述：合并文件并打印输出到标准输出</li></ul><hr><p>选项：</p><ul><li>-A:相当于-vET选项的整合，用于列出所有隐藏符号</li><li>-E:列出每行结尾的回车符$</li><li>-n:显示行号</li><li>-T:把Tab用号显示出来</li><li>-v:列出特殊字符</li></ul><hr><ul><li>cat因为查看文件是直接从头显示到尾，所以不适合来查看大文件</li></ul></blockquote></li><li><p>more命令</p><blockquote><p>more是分屏显示文件的命令</p><ul><li>命令名称：more</li><li>英文原意：file perusal filter for crt viewin</li><li>所在路径：/bin/more</li><li>执行权限：所有用户</li><li>功能描述：分屏显示文件内容</li></ul><hr><p>more命令比较简单，一般不用什么选项，命令会打开一个交互式界面，可以识别一些交互式命令。常用的交互式命令如下。</p><ul><li>空格键：向下翻页</li><li>b:向上翻页</li><li>回车键：向下滚动一行</li><li>/字符串：搜索指定的字符串</li><li>q:退出</li></ul></blockquote></li><li><p>less命令</p><blockquote><p>less命令和more命令类似，只是more是分屏显示命令，而less是分行显示命令</p><ul><li>命令名称：less</li><li>英文原意：opposite of more</li><li>所在路径：/usr/bin/less</li><li>执行权限：所有用户</li><li>功能描述：分行显示文件内容</li></ul></blockquote></li><li><p>head命令</p><blockquote><p>less命令和more命令模拟，只是more是分屏显示命令，而less是分行显示命令，其基本信息如下。</p><ul><li>命令名称：less</li><li>英文原意：opposite of more</li><li>所在路径：/usr/bin/less</li><li>执行权限：所有用户</li></ul></blockquote></li><li><p>tail命令</p><blockquote><p>既然有显示文件开头的命令，就会有显示文件结尾信息。</p><ul><li>命令名称：tail</li><li>英文原意：output the last part of files</li><li>所在路径：/usr/bin/tail</li><li>执行权限：所有用户</li><li>功能描述：显示文件结尾的内容</li></ul><hr><p>选项:</p><ul><li>-n 行数：      从文件结尾开始，显示指定行数</li><li>-f ：               监听文件的新增内容</li></ul></blockquote></li></ol><hr><h4 id="ln链接"><a href="#ln链接" class="headerlink" title="ln链接"></a>ln链接</h4><ol><li><p>ln命令</p><blockquote><ul><li>命令名称：ln</li><li>英文原意：make links between file</li><li>所在路径：/bin/ln</li><li>执行权限：所有用户</li><li>功能描述：在文件之间建立链接</li></ul><hr><p>选项：</p><ul><li>-s：建立软链接。如果不加“-s”选项，则建立硬链接文件</li><li>-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件</li></ul><hr><p>硬链接的特征：</p><ul><li>源文件和硬链接文件拥有相同的Indoe和Block</li><li>修改任意一个文件，另一个都改变</li><li>删除任意一个文件，另一个都能使用</li><li>链接标记记不清，很难确认硬链接的文件位置，不建议使用</li><li>硬链接不能链接目录</li><li>硬链接不能跨分区</li></ul><hr><p>软链接特征：</p><ul><li>软链接和源文件拥有不同的Inode和Block</li><li>两个文件修改任意一个，另一个都改变</li><li>删除软链接，源文件不受影响；删除源文件，软链接不能使用</li><li>软链接没有实际数据，只保存源文件的Inode,不论源文件多大，软链接大小不变</li><li>软链接的权限是最大权限 lrwxrwxrwx.，但是由于没有实际数据，最终访问时需要参考文件权限</li></ul><p>建议使用软链接，并且创建的时候使用绝对路径</p></blockquote></li></ol><h4 id="文件和目录都能操作的命令"><a href="#文件和目录都能操作的命令" class="headerlink" title="文件和目录都能操作的命令"></a>文件和目录都能操作的命令</h4><ol><li><p>rm命令</p><blockquote><p>rm是强大的删除命令，不仅可以删除文件，也可也删除目录</p><ul><li>命令名称：rm</li><li>英文原意：remove files or directories</li><li>所在路径：/bin/rm</li></ul><hr><p>选项：</p><ul><li>-f：      强制删除（force）</li><li>-i：   交互删除，在删除之前会询问用户</li><li>-r：  递归删除，可以删除目录（recursive）</li></ul></blockquote></li><li><p>cp命令</p><blockquote><p>cp用于复制命令</p><ul><li>命令名称：cp</li><li>英文原意：copy files and directories</li><li>所在路径：/bin/cp</li><li>功能描述：复制文件和目录</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><p>选项:</p><ul><li>-a：    相当于-dpr选项的集合</li><li>-d：     如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接</li><li>-i：      询问，如果目标文件已经存在，则会询问是否覆盖</li><li>-p：     复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）</li><li>-r：      递归复制，用于复制目录</li></ul></blockquote></li><li><p>mv命令</p><blockquote><p>mv是用来剪切的命令</p><ul><li>命令名称：mv</li><li>英文原意：move（rename） files</li><li>所在路径：/bin/mv</li><li>执行权限：所有用户</li><li>功能描述：移动文件或改名</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-f：    强制覆盖，如果目标文件已经存在，则不询问。直接强制覆盖</li><li>-i：    交互移动，=如果目标文嘉已经存在，则询问用户是否覆盖（默认选项）</li><li>-v：    显示详细信息</li></ul></blockquote></li></ol><hr><h4 id="查找命令的详细信息"><a href="#查找命令的详细信息" class="headerlink" title="查找命令的详细信息"></a>查找命令的详细信息</h4><ol><li><p>整个的linux命令都用了一本书写在了linux里面，可以通过info来查找命令的详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info ls     #意思是查看ls命令在info中的信息，很详细</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h4><ol><li><p>文件类型</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l     #通过这个命令可以查看文件或目录的详细信息</span><br><span class="line">drwxrw-xr--. 1 root root 等</span><br></pre></td></tr></table></figure><p>其中第一位便是文件类型，例如这个d 便是文件嘉的意思,这些都可以使用“info ls”来查看。其中常见的文嘉类型有：</p><ul><li>“-“:    普通文件</li><li>“b”：    快设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件/dev/sda1 就是这种文件</li><li>“c”：    字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，鼠标，键盘等。</li><li>“d”：    目录文件。Linux中一切皆文件，所以目录也是文件的一种</li><li>“l”：    软链接文件</li><li>“p“：    管道符文件。这是一种非常少见的特殊设备文件</li><li>”s“：    套接字文件。这也是一种特殊设备文件，一些服务支持Socket访问，就会产生这样的文件。</li></ul><hr><p>如果文件的权限中有“x”，即执行权限，那么这个文件便是执行文件</p></blockquote></li><li><p>文件或目录权限</p><blockquote><p>尽量使用数字权限来定义文件或目录的权限</p><ul><li><p>其中各权限所代表的数字如下：</p><blockquote><p>“r”:    4</p><p>“w”:    2</p><p>“x”:    1</p></blockquote></li><li><p>644:这是文件的基本权限，代表所有者拥有读、写权限，而所有组，其他人只有读权限</p></li><li><p>755：这是文件的执行权限和目录的基本权限，代表所有者拥有读、写和执行权限，而所属组和其他人拥有读和执行权限</p></li><li><p>777：这是最大权限。在实际的生产服务器中，要尽力避免给文件或目录赋予这样的权限，这回造成一定的安全隐患</p></li></ul></blockquote></li></ol><hr><h4 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h4><ol><li><p>chown命令：</p><blockquote><p>chown是修改文件和目录的所有者和所属组的命令</p><ul><li>命令名称：chown</li><li>英文原意：change file owner and group</li><li>所在路径：/bin/chown</li><li>执行权限：所有用户</li><li>功能描述：修改文件和目录的所有者和所属组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 所有者：所属组 文件或目录</span><br><span class="line">选项：</span><br><span class="line">    -R：    递归设置权限，也就是给予子目录中所有的文件设置权限</span><br></pre></td></tr></table></figure><hr><p>普通用户不能修改文件的所有者，哪怕自己是这个文件的所有者也不行，只有超级用户才能修改文件的所有者</p><p>普通用户可以修改所有者是自己的文件的权限</p><p>其中如果不想修改所属组的话可以不加“：所属组”</p><p>一般修改文件或目录的所有者和所属组着一个命令就够了，不太怎么经常使用chgrp命令</p></blockquote></li></ol><h4 id="权限含义"><a href="#权限含义" class="headerlink" title="权限含义"></a>权限含义</h4><ol><li><p>权限含义的解释：</p><blockquote><ul><li><p>权限对文件的作用：</p><blockquote><ul><li><p>读（r）：  对文件有读（r）权限，代表可以读取文件中的数据。如果把权限对应到命令上，那么一旦对文件有读（r）权限，就可以对文件执行cat、more、less、head、tail等文件查看</p></li><li><p>写（w）：对文件有写（写）权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件有写（w）权限，就可以对文件执行vim、echo等修改文件数据的命令。注意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据。如果要想删除文件，则需要对文件的上级目录拥有写权限。</p><blockquote><p>因为文件的信息是写在上一级目录的block块中的，此文件Inode节点中的位置是对应着这个文件的数据空间块中，这里只有这个文件中写的数据，而这个文件的Inode节点中则存放着I节点号、这个文件中数据的权限，时间和对应block块的位置，而在上一级目录文件中的block存放着这个目录中子文件或者子目录的信息和对应的I节点号，所以想要对这个文件进行删除操作，必须在上一级文件中拥有写权限</p></blockquote></li><li><p>执行（x）：对文件有执行（x）权限，代表文件拥有了执行权限，可以运行。在Linux中，只要文件有执行（x）权限，这个文件就是执行文件了。只是这个文件到底能不能正确执行，不仅需要执行（x）权限，还要看文件中的代码是不是正确的语言代码。对文件来说，执行（x）权限是最高权限。</p></li></ul></blockquote></li><li><p>权限对目录的作用:</p><blockquote><ul><li>读（r）：对目录有读（r）权限，代表可以查看目录下的内容，也就是可以查看目录下有哪些子文件和子目录，如果把权限对应到命令上，那么一旦对目录拥有了读（r）权限，就可以在目录下执行ls命令，查看目下的内容了</li><li>写（w）：对目录有写（w）权限，代表可以修改目录下的数据，也就是可以在目录中新建、删除、复制、剪切子文件或子目录。如果把权限对应到命令上，那么一旦对目录拥有了写（w）权限，就可以在目录下执行touch、rm、cp、mv命令。对目录来说，写（w)权限是最高权限</li><li>执行（x）：目录是不能运行的，那么对于目录拥有执行（x）权限，代表可以进入目录。如果把权限对应到命令上，那么一旦对目录拥有了执行（x）权限，就可以对目录执行cd命令，进入目录。</li></ul></blockquote></li><li><p>目录的可用权限</p><blockquote><p>目录的可用权限其实只有一下几个</p><ul><li>0：任何权限都不赋予</li><li>5：基本的目录浏览和进入权限</li><li>7：完全权限</li></ul></blockquote></li></ul><hr><p>注意：这些普通权限对root是没有用的，只能针对普通用户</p></blockquote></li><li><p>新建文件和目录的默认最大权限</p><blockquote><ul><li>对于文件来讲，新建文件的默认最大权限是666,没有执行（x）权限，这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予</li><li>对于目录来讲，新建目录的默认最大权限是777,这是因为对于目录而言，执行（x）权限仅仅代表进入目录，所以即使建立新建文件时直接默认赋予，也没有什么危险</li></ul></blockquote></li></ol><hr><h4 id="umask权限"><a href="#umask权限" class="headerlink" title="umask权限"></a>umask权限</h4><ol><li><p>查看系统的umask权限</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umask       #用八进制数值显示umask权限</span><br><span class="line">0022</span><br><span class="line">umask -S    #用字母表示文件和目录的初始权限</span><br><span class="line">u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx</span><br></pre></td></tr></table></figure></blockquote></li><li><p>umask权限的计算方法</p><p>先了解新建文件和目录的默认最大权限</p><ul><li>对文件来讲，新建文件的默认最大权限是666，没有执行（x）权限。这是因为执行权限对我呢见来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。</li><li>对目录来讲，新建目录的默认最大权限是777。这是因为对目录而言，执行（x）权限仅仅代表进入目录，所以即使建立新目录是直接默认赋予，也没有什么危险。</li></ul></li><li><p>umask权限的计算方法</p><blockquote><p>按照官方的标准算法，umask默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到正确的新建文件和目录的默认权限。这种方法即不好计算，也不好理解，并不推荐。</p></blockquote><p>这里还是按照权限字母来讲解umask权限计算方法，先按照默认的umask值是022来分别计算下新建文件和 目录的默认权限</p><ul><li><p>文件的默认权限最大只能是666，而umask的值是022</p><p>“-rw-rw-rw-” 减去 “—–w–w-” 等于 “-rw-r–r–”</p></li><li><p>目录的默认权限最大可以是777，而umask的值是022</p><p>“drwxrwxrwx” 减去 “d—-w–w-” 等于“drwx-r-xr-x”</p></li></ul><p>注意：umask默认权限的计算绝不是数字直接相减。</p><p>例如umask是033呢？</p><ul><li><p>文件的默认权限最大只能是666，而umask的值是033</p><p>“-rw-rw-rw” 减去 “—–wx-wx” 等于 “-rw-r–r–”</p></li></ul><hr><p>如果想要永久修改这个默认umask权限，在linux中都需要修改配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;profile     #存放umask权限的配置文件就在这里</span><br><span class="line">#这是一个环境变量配置文件</span><br></pre></td></tr></table></figure><p>其中普通用户的UID号&gt;500</p><p>500以内是给系统用户的</p><p>这个默认权限够用了，基本不需要修改</p></li></ol><hr><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><ol><li><p>man 命令</p><p>man是最常见的帮助命令，也是最主要的帮助命令：</p><ul><li>命令名称：man</li><li>英文原意：format and display the on-line manual pages</li><li>所在路径：/usr/bin/man</li><li>执行权限：所有用户</li><li>功能描述：显示联机帮助手册</li></ul><p>命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># man [选项] 命令</span><br><span class="line">选项：</span><br><span class="line">-f:查看命令拥有那个级别的帮助</span><br><span class="line">-k:查看和命令相关的所有帮助</span><br></pre></td></tr></table></figure><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>上箭头</td><td>向上移动一行</td></tr><tr><td>下箭头</td><td>向下移动一行</td></tr><tr><td>PgUp</td><td>向上翻页</td></tr><tr><td>PgDn</td><td>向下翻页</td></tr><tr><td>g</td><td>移动到第一列</td></tr><tr><td>G</td><td>移动到最后一页</td></tr><tr><td>q</td><td>推出</td></tr><tr><td>/字符串</td><td>从当前页向下搜索字符串</td></tr><tr><td>？字符串</td><td>从当前页向上搜索字符串</td></tr><tr><td>n</td><td>当搜索字符串时，可以使用n键找到下一个字符串</td></tr><tr><td>N</td><td>当搜索字符串时，使用N键反向查询字符串。也就是说，如果使用“/字符串”方式搜索，则N键表示向上搜索字符串；如果使用“？字符串”方式搜索，则N键表示向下搜索字符串</td></tr><tr><td></td><td></td></tr></tbody></table><p>基本下面两个记得/字符串和n就行</p><hr><p>man命令的帮助级别</p><table><thead><tr><th>级别</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>普通用户可以执行的系统命令和可执行文件的帮助</td></tr><tr><td>2</td><td>内核可以调用的函数和工具的帮助</td></tr><tr><td>3</td><td>C语言函数的帮助</td></tr><tr><td>4</td><td>设备和特殊文件的帮助</td></tr><tr><td>5</td><td>配置文件的帮助</td></tr><tr><td>6</td><td>游戏的帮助（个人版的Linux中是有游戏的）</td></tr><tr><td>7</td><td>杂项的帮助</td></tr><tr><td>8</td><td>超级用户可以执行的系统命令的帮助</td></tr><tr><td>9</td><td>内核的帮助</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man -f 或  whatis</span><br><span class="line">#查看命令拥有哪个级别的帮助</span><br></pre></td></tr></table></figure><hr></li><li><p>info 命令</p><p>info命令是一套完整的资料，每个单独命令的v帮助命令 的帮助信息这个ishi这套完整资料中的某一个章节</p><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>上箭头</td><td>向上移动一行</td></tr><tr><td>下箭头</td><td>向下移动一行</td></tr><tr><td>PgUp</td><td>向上翻一页</td></tr><tr><td>PgDn</td><td>向下翻一页</td></tr><tr><td>Tab</td><td>在有“*”符号的节点间进行切换</td></tr><tr><td>回车</td><td>进入有“*”符号的子页面，查看详细帮助信息</td></tr><tr><td>u</td><td>进入上一层信息（回车是进入下一层信息）</td></tr><tr><td>n</td><td>进入下一小节信息</td></tr><tr><td>p</td><td>进入上一小节信息</td></tr><tr><td>？</td><td>查看帮助信息</td></tr><tr><td>q</td><td>退出info信息</td></tr></tbody></table><p>这本书是linux里最详细的书，但是太多都是英文太难了，所以基本建议使用man，man查不到时再使用info</p><hr></li><li><p>–help选项</p><p>绝大多数命令都是可以使用“–help”选项来查看帮助，这也是一种获取帮助的方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ls --help</span><br></pre></td></tr></table></figure><p>这种方法非常简单，输出的帮助信息基本上是man命令的信息简要版。</p></li></ol><hr><h4 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h4><ol><li><p>whereis命令</p><p>whereis是搜索系统命令的命令，也就是说，whereis命令不能搜索普通文件，而只能搜索系统命令。</p><ul><li>命令名称：whereis</li><li>英文愿意：locate the binary , source ,and manual page files for a command</li><li>所在路径：/usr/bin/whereis</li><li>执行权限：所有用户</li><li>功能描述：查找二进制命令那个，源文件和帮助文档的命令</li></ul><hr></li><li><p>which 命令</p><p>which也是搜索系统命令的命令。和whereis命令的区别在于：</p><ul><li><p>whereis 命令可以在查找到二进制命令的同时，查找到帮助文档的位置;</p></li><li><p>而which命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名（alias）命令</p><blockquote><p>可以通过alias命令来查看linux中有别名的命令</p></blockquote></li></ul><hr></li><li><p>locate命令</p><p>locate命令才是可以按照文件名搜索普通文件的命令</p><ul><li>优点：按照数据库搜索，搜索速度快，消耗资源小。数据库位置/var/lib/mlocate/mlocate.db</li><li>缺点：只能按照文件名来搜索文件，而不能执行更多复杂的搜索，比如按照权限、大小、修改时间等搜索文件。</li></ul><blockquote><p>locate之所以消耗的资源少，快。是因为他原本就有一个数据库，这个命令是直接从这个数据库中搜索，范围就会变小，所有的就快，消耗的资源就要少。</p><p>基本关于文件搜索比find更常用</p></blockquote><p>updatedb</p><p>   强制更新数据库（/var/lib/mlocate/mlocate.db）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># sudo vim &#x2F;etc&#x2F;updatedb.conf</span><br><span class="line">PRUNE_BIND_MOUNTS &#x3D; &quot;yes&quot;</span><br><span class="line">#开启搜索限制，也就是让这个配置文件生效</span><br><span class="line">PRUNENAMES &#x3D; &quot;......&quot;</span><br><span class="line">#在locate执行搜索时，禁止搜索带有这些扩展名的文件</span><br><span class="line">PRUNEPATHS &#x3D; &quot;......&quot;</span><br><span class="line">#在locate执行搜索是，禁止搜索这些系统目录</span><br></pre></td></tr></table></figure><p>这就是有些时候更新了数据库后还是搜索不到的原因是配置文件中禁止了对这些文件目录的搜索。</p></li><li><p>find 命令</p><p>按照文件名搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">-name :按照文件名搜索</span><br><span class="line">-iname :按照文件名搜索，不区分文件名大小写</span><br><span class="line">-inum :按照inode号搜索</span><br></pre></td></tr></table></figure><p> 搜索路径范围越大，所消耗的资源越多，速度也越慢</p><hr><p>按照文件大小搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项:</span><br><span class="line">-size [+|-]大小 ：按照指定大小搜索文件</span><br></pre></td></tr></table></figure><p>这里的“+”的意思是搜索比指定大小还要大的文件，“-”的意思是搜索比指定大小还要小的文件。</p><hr><p>按照修改时间搜索</p><p>linux中的文件有访问时间（atime）、数据修改时间（mtime）、状态修改时间（ctime）这三个时间，并且time在linux中的默认单位是天。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">-atime:按照文件访问时间搜索</span><br><span class="line">-mtime:按照文件数据修改时间搜索</span><br><span class="line">-ctime:按照文件状态修改时间搜索</span><br></pre></td></tr></table></figure><blockquote><p>linux中min的单位是分</p><p>一般是按天来使用</p></blockquote><p>这里用mtime数据修改时间来举例，重点突出“[+-]”时间的含义</p><ul><li>-5：    代表5天内修改的文件</li><li>5：      代表前5～6天那一天修改的文件</li><li>+5：    代表6天前修改的文件</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;要背的目录文件&quot;&gt;&lt;a href=&quot;#要背的目录文件&quot; class=&quot;headerlink&quot; title=&quot;要背的目录文件&quot;&gt;&lt;/a&gt;要背的目录文件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装后的三个文件&lt;/li&gt;
&lt;li&gt;牢记&lt;/li&gt;
&lt;li&gt;搜索命令中locate中的数</summary>
      
    
    
    
    
  </entry>
  
</feed>
